% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/abr_densfunctions.R
\name{abr_density}
\alias{abr_density}
\alias{abr_cumdens}
\alias{abr_density.control}
\alias{abr_cumdensquant}
\alias{maxdens}
\title{Kernel Density Estimate for ZD and MIC data}
\usage{
abr_density(
  x,
  cutoff = 5.5,
  method = c("density", "evmix"),
  control = abr_density.control()
)

abr_cumdens(
  x,
  cutoff = 5.5,
  method = c("evmix", "density", "spline", "fmm"),
  control = abr_density.control()
)

abr_density.control(bw = 1, cut = 3,  n=512, bcmethod = "renorm", proper = TRUE)

abr_cumdensquant(
  x,
  p = 0.5,
  cutoff = 5.5,
  method = c("density", "evmix", "spline", "fmm"),
  control = abr_density.control()
)

maxdens(
  x,
  cutoff = 5.5,
  from = min(x),
  to = max(x),
  method = c("density", "evmix"),
  control = abr_density.control()
)
}
\arguments{
\item{x}{vector of antibiotic resistance observations, given as zone
diameter (zd) or log of minimum inhibitory concentration (mic).
Note that for \code{abr_density} x must contain raw observations,
not frequencies, cf. \code{\link{unbin}}, while for
abr_cumdens x and y contain binned data. If y is omitted, x must contain a
two-column matrix with value and frequency.}

\item{cutoff}{cutoff value (disc diameter) in case of zd data}

\item{method}{character which density method to use: \code{'density'},
\code{'evmix'} (function \code{pbckden}), \code{'spline'},
 or \code{'fmm'} (monotone spline)}

\item{control}{options passed to the density estimation methods, see \code{\link{abr_density.control}}}

\item{bw}{the smoothing bandwidth to be used,
see \code{\link{density}} for details.}

\item{cut}{by default, the values of from and to are cut bandwidths beyond
the extremes of the data, see \code{\link{density}} for details}

\item{n}{the number of equally spaced points at which the density is to be
estimated, see \code{\link{density}} for details}

\item{bcmethod}{character, boundary correction method}

\item{proper}{logical, whether density is renormalised to integrate to unity}

\item{p}{vector of probability quantiles}

\item{from, to}{search range for maximum (= mode) search}
}
\value{
data frame with
  \itemize{
    \item x zone diameter resp. mic value
    \item y density estimate
  }
}
\description{
Estimate kernel density for antibiotic resistance data using either standard
  density estimation with Gaussian kernels or boundary corrected density estimation
  with function \code{pbckden} from package \pkg{evmix}.
}
\examples{

opar <- par(no.readonly = TRUE)
## ===== minimum inhibitory concentrations (MIC) data =====
data("micdata")
micdata$freq <- with(micdata, ifelse(is.na(freq), 0, freq))

par(las = 2, mar=c(9,4,4,2)+.1)

##' relative frequencies
y <- micdata$freq / sum(micdata$freq)
x <- log2(micdata$conc)

plot(y ~ x, type = "h", axes = FALSE, xlab="", ylab="rel. frequency")
axis(2)
axis(1)
axis(1, line=3, at = log2(micdata$conc), label = round(micdata$conc, 4))
mtext("log2(conc)", side=1, line=1.5, las=1)
mtext("conc", side=1, line=6, las=1)

##' standard R function with weights
dens <- density(x, weights=y, bw=2/3)
lines(dens)

## ===== zone diameter (ZD) data =====
freq <- c(36, 0, 2, 3, 4, 8, 9, 14, 10, 9, 3, 1, 8, 2, 4, 8, 20,
          45, 40, 54, 41, 22, 8, 3, 3, 0, 0, 0, 0, 2)

relfreq <- freq/sum(freq)
bins <- 5 +(1:length(freq))
mids <- bins + 0.5

plot(mids, relfreq, type="h")

## ----- standard R function -----
edf <- density(mids, weights=relfreq, bw=2/3, from=0, to=40)
lines(edf)

## ----- same, but with different interface -----
edf2 <- abr_density(unbin(mids, freq), control=list(bw=2/3))
lines(edf2, col="red", lty="dotted")

## ----- boundary corrected density from package evmix -----
bcd <- abr_density(unbin(mids, freq), method="evmix")
lines(bcd, col="blue", lty="dotted")

## ===== maximum of density function (uses optimizer) =====
maxdens(unbin(mids, freq))

## ----- cumulative density -----
plot(abr_cumdens(unbin(mids, freq), method="fmm"), type="l")

## ----- quantiles -----
prob <- c(0.5, 0.95, 0.99)
abline(h=prob, lty="dotted")
abline(v=abr_cumdensquant(unbin(mids, freq),
                          p=prob, method="fmm"), lty="dotted")

par(opar)



}
\seealso{
\code{\link{density}}, \code{\link{dbckden}}
}
